{"ts":1380545824725,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n* Offreg jQuery plug-in\n* Make Like Print\n*\n* @author Jean-Christophe Nicolas <mrjcnicolas@gmail.com>\n* @homepage http://bite-software.co.uk/offreg/\n* @version 0.0.1\n* @license MIT http://opensource.org/licenses/MIT\n* @date 26-06-2013\n*/\n\nvar Plugin = function(me,img,png,rot,axis){\n\tthis.el = me;\n\tthis.img = img;\n\tthis.w = 0;\n\tthis.h = 0;\n\tthis.rot = rot;\n\tthis.axis = (!axis)? rot : axis;\n\n\tthis.png = (png)? png : false;\n\tthis.bg = '#fff';\n\t\n\tthis.pixelData = [];\n\tthis.rgb = [];\n\n\tthis.init();\n}\n\nPlugin.prototype.init = function(){\n\n\tvar $this = this;\n\n\tthis.c = document.createElement('canvas');\n\tthis.ctx = this.c.getContext(\"2d\");\n\t\t\n\t// initialise dimensions\n\t$this.w = this.img.width;\n\t$this.h = this.img.height;\n\t\n\t$this.c.width = $this.w;\n\t$this.c.height = $this.h;\n\t\n\t$this.padding = 0.9; \t// percentage reduction of image within origin boundaries\n\t$this.imgw = $this.w * $this.padding;\n\t$this.imgh = $this.h * $this.padding;\n\n\t$this.buildLayerData();\n\n}\n\nPlugin.prototype.buildLayerData = function(){\n\n\tvar pixels = this.pixelData,\n\t\tdegMax = 2 * this.rot,\n\t\toffMax = 10 * this.axis;\n\t\n\tif(degMax < 0.1){\n\t\tdegMax = 0.1;\n\t}\n\tif(offMax < 0.1){\n\t\toffMax = 0.1;\n\t}\n\n\tfor(var i=0;i<3;i++){\t\t// construct postioning of offsets\n\t\t\n\t\tvar deg = -degMax + Math.random()*(degMax*2),\n\t\t\toffx = Math.random()*(offMax*2) -offMax,\n\t\t\toffy = Math.random()*(offMax*2) -offMax;\n\n\t\tthis.ctx.save();\n\n        this.ctx.translate(this.w/2,this.h/2);\n        this.ctx.rotate(this.toRad(deg));\n        \n        if(!this.png){ // if jpg -> set bg colour to $(selector)\n        \tthis.ctx.fillStyle = this.bg;\n\t\t\tthis.ctx.fillRect(-this.imgw*1.5,-this.imgh*1.5, this.w*3, this.h*3);\n\t\t}\n\n        this.ctx.drawImage(this.img,-this.imgw/2,-this.imgh/2,this.imgw,this.imgh);   \n        \n        pixels[i] = this.ctx.getImageData(offx,offy,this.w ,this.h);\n        \n        this.ctx.restore(); \n        // this.ctx.clearRect(0,0,this.w,this.h);\n        \n\t}\n\n\tthis.convertToRGBChannels();\n}\n\n\nPlugin.prototype.convertToRGBChannels = function(){\n\n\tvar rgb = this.rgb; \t\t// rgb -> temp place to copy the pixel data - \n\t\t\t\t\t\t\t\t// convert them to their respective colour channel - \n\t\t\t\t\t\t\t\t// then return them to original imageData source.\n\n\tfor(var ch=0;ch<3;ch++){\n\n\t\trgb[ch] = this.pixelData[ch].data;\n\n\t\tvar channel = rgb[ch];\n\t\n\t\tfor (var i=0; i<channel.length - 4; i+=4) {\n\n\t\t\tswitch(ch){\n\t\t\t\tcase 0: \t\t// red channel\n\t\t\t\t\tchannel[i] = 255 - channel[i];         \n\t    \t        channel[i + 1] = 0;\n    \t    \t    channel[i + 2] = 0;\n    \t    \tbreak;\n    \t    \tcase 1: \t\t// green channel\n\t\t\t\t\tchannel[i] = 0        \n\t    \t        channel[i + 1] = 255 - channel[i + 1]; ;\n    \t    \t    channel[i + 2] = 0;\n    \t    \tbreak;\n    \t    \tcase 2: \t\t// blue channel\n\t\t\t\t\tchannel[i] = 0;         \n\t    \t        channel[i + 1] = 0;\n    \t    \t    channel[i + 2] = 255 - channel[i + 2];\n    \t    \tbreak;\n\t\t\t}\n           \n        }\n        this.pixelData[ch].data = channel;\n        \n\t}\n\n\tthis.merge();\n}\n\n\nPlugin.prototype.merge = function(){\n\n\tvar output = this.pixelData[1];\n\n\tthis.screenBlend(this.pixelData[0],output); // merge red & green\n\tthis.screenBlend(this.pixelData[2],output); // merge [red/green] with blue\n\n\tthis.invert(output);\n\n\tthis.deploy(output);\n}\n\nPlugin.prototype.deploy = function(dst){\n\t\n\tthis.ctx.putImageData(dst,0,0);\n\n\tif(!this.png){ // dirty jpeg hack -> was creating a black background -> line width test on smaller images\n\t\tthis.ctx.strokeStyle=this.bg;\n\t\tthis.ctx.lineWidth=25; // needs to become dynamic based on source dimensions\n\t\tthis.ctx.strokeRect(0,-0,this.w,this.h);\n\t}\n        \n    this.el.appendChild(this.convertCanvasToImage(this.c));\n}\n\nPlugin.prototype.screenBlend = function(src,dst){\n\n\tvar sA, dA, len = dst.data.length;\n    var sRA, sGA, sBA, dRA, dGA, dBA, dA2;\n    var demultiply;\n\n    for (var px=0;px<len;px+=4){\n        sA  = src.data[px+3]/255;\n        dA  = dst.data[px+3]/255;\n        dA2 = (sA + dA - sA*dA);\n        dst.data[px+3] = dA2*255;\n\n        sRA = src.data[px  ]/255*sA;\n        dRA = dst.data[px  ]/255*dA;\n        sGA = src.data[px+1]/255*sA;\n        dGA = dst.data[px+1]/255*dA;\n        sBA = src.data[px+2]/255*sA;\n        dBA = dst.data[px+2]/255*dA;\n\n        demultiply = 255 / dA2;\n\n        dst.data[px  ] = (sRA + dRA - sRA*dRA) * demultiply;\n        dst.data[px+1] = (sGA + dGA - sGA*dGA) * demultiply;\n        dst.data[px+2] = (sBA + dBA - sBA*dBA) * demultiply;\n    }\n\n}\nPlugin.prototype.invert = function(pixels){\n\n\tfor(var i=0;i<pixels.data.length-4;i+=4){\n\t    pixels.data[i] = 255 - pixels.data[i];\n\t    pixels.data[i+1] = 255 - pixels.data[i+1];\n\t    pixels.data[i+2] = 255 - pixels.data[i+2];\n\t}\n}\nPlugin.prototype.toRad = function(deg){\n    return deg/180 * Math.PI;\n}\nPlugin.prototype.convertCanvasToImage = function(canvas) {\n    var image = new Image();\n    console.log(canvas)\n    image.src = (this.png)? canvas.toDataURL(\"image/png\") : canvas.toDataURL(\"image/jpeg\");\n    return image;\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":4954}]],"length":4954}
